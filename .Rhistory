## --------------------------------------------------------------#
#Pre-install packages used by SAVM to bypass issues
#----------------------------#
library(devtools)
library(pak)
library(cli)
library(dplyr)
library(ggplot2)
library(patchwork)
library(rlang)
library(sf)
library(stats)
library(tmap)
library(tools)
library(units)
library(utils)
library(viridis)
devtools::load_all("SAVM_v0.0.1")
library(SAVM)
library(sf)
library(stars)
# Lake Erie boundaries polygon
le_bound <- system.file("example", "lake_erie.gpkg", package = "SAVM") |>
sf::st_read() |>
sf::st_transform(crs = 3857)
View(le_bound)
View(le_bound[[2]][[1]])
### Read in Jons data
#----------------------------#
#Shapefiles
LH_shapefile <- st_read("02 - Data/SAV_2024 Samples - Fetch Ready/LKHuron/LKHuron_Land_fromGLAF_Water_WGS_Feb2020.shp")
### Format data
#----------------------------#
#Reproject to use meters
LH_shapefile_m <- st_transform(LH_shapefile, crs = 32617)
View(LH_shapefile_m)
str(le_bound)
### Read in Jons data
#----------------------------#
#Shapefiles
LH_shapefile <- st_read("02 - Data/SAV_2024 Samples - Fetch Ready/LKHuron/LKHuron_Land_fromGLAF_Water_WGS_Feb2020.shp")
LO_shapefile <- st_read("02 - Data/SAV_2024 Samples - Fetch Ready/LKO/LKO_Land_fromGLAF_Water_WGS_Feb2020.shp")
#Points
LH_data_raw <- read.csv("02 - Data/SAV_2024 Samples - Fetch Ready/SAV_2024_LakeHuronPoints_20May2025.csv")
LO_data_raw <- read.csv("02 - Data/SAV_2024 Samples - Fetch Ready/SAV_2024_LakeOntarioPoints_20May2025.csv")
### Format data
#----------------------------#
#Reproject to use meters
LH_shapefile_m <- st_transform(LH_shapefile, crs = 32617)
LO_shapefile_m <- st_transform(LO_shapefile, crs = 32617)
#Turn from table into spatial object
LH_data <- st_as_sf(LH_data_raw, coords = c("POINT_X", "POINT_Y"), crs = 4326)
LO_data <- st_as_sf(LO_data_raw, coords = c("POINT_X", "POINT_Y"), crs = 4326)
#Reproject to use meters
LH_data_m <- st_transform(LH_data, crs = 32617)
LO_data_m <- st_transform(LO_data, crs = 32617)
### Calculate fetch
#----------------------------#
LH_fetch <- compute_fetch(points=LH_data_m, polygon=LH_shapefile_m)
rlang::last_trace()
st_as_sf(LH_data)
st_as_sf(LH_shapefile)
ggplot()+
geom_sf(data=LO_shapefile_m, colour = "black", fill=NA, inherit.aes = FALSE)+
geom_sf(data=LO_data_m, colour = "blue", fill=NA, inherit.aes = FALSE)+
ylab("Northing")+xlab("Easting")+
theme_classic()
LO_fetch <- compute_fetch(points=LO_data_m, polygon=LO_shapefile_m)
st_as_sf(le_bound)
st_as_sf(LH_shapefile_m)
LH_shapefile_aligned <- LH_shapefile_m %>%
#st_transform(crs = 3857) %>%
# Keep only a single identifier field to match le_bound's format
transmute(OBJECTID_1 = 0) %>%
# Ensure geometry is still valid
st_make_valid()
View(LH_shapefile_aligned)
LH_fetch <- compute_fetch(points=LH_data_m, polygon=LH_shapefile_aligned)
View(LH_data_m)
# Lake Erie boundaries polygon
le_bound <- system.file("example", "lake_erie.gpkg", package = "SAVM") |>
sf::st_read() |>
sf::st_transform(crs = 3857)
# Lake Erie study zone: read
study_zone <- system.file("example", "study_zone.geojson", package = "SAVM") |>
read_sav(spacing = 2000)
View(study_zone)
study_zone[["points"]][["points"]]
study_zone[["points"]][["geometry"]]
# Lake Erie boundaries polygon
le_bound <- system.file("example", "lake_erie.gpkg", package = "SAVM") |>
sf::st_read() |>
sf::st_transform(crs = 3857)
# Lake Erie study zone: read
study_zone <- system.file("example", "study_zone.geojson", package = "SAVM") |>
read_sav(spacing = 2000)
View(study_zone)
fetch <- compute_fetch(study_zone$points, le_bound)
fetch <- compute_fetch(study_zone$points, le_bound)
fetch
View(fetch)
View(fetch[["mean_fetch"]])
fetch[["transect_lines"]]
# Check CRS (again, just to verify both are now in EPSG:3857)
st_crs(LH_data_m)
st_crs(LH_shapefile_aligned)
st_within(LH_data_m, LH_shapefile_aligned)
# Step 1: Define required packages
# Only specify version numbers where needed; others will default to NA
required_packages <- c(
raster = "3.5-15",         # Example with minimum version
tidyverse = "2.0.0",
ggmap = NA,                # No minimum version required
plotly = NA,
sjPlot = NA,
ggsn = NA,
caret = "6.0-93",
pdp = NA,
ROCR = NA,
pROC = NA,
lme4 = NA,
data.table = NA,
patchwork = NA,
rgdal = NA,
leaflet = NA,
rio = NA,
readxl = NA,
emmeans = NA,
lubridate = NA,
vegan = NA,
corrplot = NA,
randomForest = "4.7-1.1",
rfUtilities = NA)
packages_to_install <- c()  # initialize an empty vector
for (loop_pkg in names(required_packages)) {
loop_required_version <- required_packages[[loop_pkg]]
if (!requireNamespace(loop_pkg, quietly = TRUE)) {
# Package not installed
packages_to_install <- c(packages_to_install, loop_pkg)
} else if (!is.na(loop_required_version)) {
# Package installed, but check if version meets the requirement
loop_installed_version <- utils::packageVersion(loop_pkg)
if (loop_installed_version < loop_required_version) {
# Version too old, mark for install/update
packages_to_install <- c(packages_to_install, loop_pkg)
}
}
# If package is installed and no version is specified, do nothing
}
#Clean up
rm(loop_pkg); rm(loop_installed_version); rm(loop_required_version)
# Step 4: Install missing or outdated packages
if (length(packages_to_install) > 0) {
install.packages(packages_to_install)
}
# Step 5: Load all required packages
lapply(names(required_packages), library, character.only = TRUE)
#Pre-install packages used by SAVM to bypass issues
#----------------------------#
library(devtools)
library(pak)
library(cli)
library(dplyr)
library(ggplot2)
library(patchwork)
library(rlang)
library(sf)
library(stats)
library(tmap)
library(tools)
library(units)
library(utils)
library(viridis)
devtools::load_all("SAVM_v0.0.1")
#Pre-install packages used by SAVM to bypass issues
#----------------------------#
library(devtools)
library(pak)
library(cli)
library(dplyr)
library(ggplot2)
library(patchwork)
library(rlang)
library(sf)
library(stats)
library(tmap)
library(tools)
library(units)
library(utils)
library(viridis)
devtools::load_all("SAVM_v0.0.1")
`pkgbuild::check_build_tools(debug = TRUE)`
pkgbuild::check_build_tools(debug = TRUE)
